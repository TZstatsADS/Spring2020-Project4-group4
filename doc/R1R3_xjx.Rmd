---
title: "A3 + R1 + R3 + P3"
author: "Jinxu Xiang"
output: 
 html_notebook
 pdf_document
---

```{r, include = F}
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(cache = T)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
options(mc.cores = parallel::detectCores())
library(dplyr)
library(tidyr)
library(ggplot2)
library(anytime)
```


## Load data, split dataset

```{r}
data <- read.csv("../data/ml-latest-small/ratings.csv")
```

```{r}
data$timestamp <- anydate(data$timestamp)
data <- data %>% 
  group_by(userId) %>% 
  mutate(timediff = (timestamp - mean(timestamp)) %>% as.numeric) %>% 
  ungroup() %>%
  arrange(timestamp)
```

```{r}
set.seed(0)
## shuffle the row of the entire dataset
data <- data[sample(nrow(data)),]
## get a small dataset that contains all users and all movies
unique.user<-duplicated(data[,1])
unique.movie<-duplicated(data[,2])
index<-unique.user & unique.movie
all.user.movie <- data[!index,]

## split training and test on the rest
rest <- data[index,]
test_idx <- sample(rownames(rest), round(nrow(data)/5, 0))
train_idx <- setdiff(rownames(rest), test_idx)

## combine the training with the previous dataset, which has all users and all movies
data_train <- rbind(all.user.movie, data[train_idx,])
data_test <- data[test_idx,]

## sort the training and testing data by userId then by movieId, 
## so when we update p and q, it is less likely to make mistakes
data_train <- arrange(data_train, userId, movieId)
data_test <- arrange(data_test, userId, movieId)
```

```{r}
U <- length(unique(data$userId))
I <- length(unique(data$movieId))
```

## define RMSE
```{r}
RMSE <- function(rating, est_rating) {
  error <- rep(NA, nrow(rating))
  for (i in 1:nrow(rating)) {
    a <- as.character(rating[i,1])
    b <-as.character(rating[i,2])  
    error[i] <- (rating[i,3]-est_rating[a, b])^2
  }
  error = error %>% unlist()
  return(sqrt(mean(error)))
}

```

## A3 + R1 + R3
```{r}
# Alternating least squares
# a function returns a list containing factorized matrices p and q, training and testing RMSEs.

ALS.R1R3 <- function(f = 10, lambda = 5, beta = 0.4, max.iter = 5,
            train = data_train, test = data_test) {
  # Step 0: calculte dev
  train = train %>% mutate(dev = ifelse(timediff>0, 1, -1)*abs(timediff)^beta)
  test = test %>% mutate(dev = ifelse(timediff>0, 1, -1)*abs(timediff)^beta)
  # Step 1: Initialize Movie matrix (q), User matrix (p), Movie bias(bi) and User bias(bu)
  p <- matrix(runif(f*U, -10, 10), ncol = U) 
  colnames(p) <- levels(as.factor(data$userId))
  
  q <- matrix(runif(f*I, -10, 10), ncol = I)
  colnames(q) <- levels(as.factor(data$movieId))
  
  bu <- matrix(rep(0, U), ncol = U)
  colnames(bu) <- levels(as.factor(data$userId))
  
  bi <- matrix(rep(0, I), ncol = I)
  colnames(bi) <- levels(as.factor(data$movieId))
  
  R <- matrix(rep(0, U*I), ncol = I)
  colnames(R) <- levels(as.factor(data$movieId))
  
  au <- matrix(rep(0, U), ncol = U)
  colnames(au) <- levels(as.factor(data$userId))
  
  # mean of all the ratings in train data set.
  mu <- mean(train$rating)
  
  # sort movie id to make sure that they are from small to large
  movie.id <- sort(unique(data$movieId))
  
  # sort the data by userid then by movie id
  train <- arrange(train, userId, movieId)
  
  
  # set vacant cells to record train and test rmse
  train_RMSE <- c()
  test_RMSE <- c()
  
  for (l in 1:max.iter) {
    S = Sys.time()
    # Step 2: Fix q, solve p
    # we need new factors to add bu, bi into calculation
    q_idb <- rbind(rep(1,I), q)
    colnames(q_idb) <- levels(as.factor(data$movieId))
    p_new <- rbind(au, bu, p)
    
    for (u in 1:U) {
      # find all the moives rated by user u
      i_ratedby_u <- as.character(train[train$userId==u,]$movieId)
      x <- train[train$userId==u,]$rating
      dev <- train[train$userId==u,]$dev
      R_m_u <- matrix(x,ncol=length(x),nrow = 1)
      
      #calculate new q
      q_new = rbind(dev, q_idb[,i_ratedby_u])
      colnames(q_new) <- colnames(q_idb[,i_ratedby_u])
      # update p.tilde
      p_new[,u] <- solve(q_new %*% t(q_new) + lambda * diag(f+2)) %*%
        q_new %*% t(R_m_u - mu - bi[,i_ratedby_u])
    }
    
    # update bu and p
    au[1,] <- p_new[1, ]
    bu[1,] <- p_new[2, ]
    p <- p_new[-c(1,2), ]
    
    # Step 3: Fix p, solve q
    # we need new factors to add bu, bi into calculation
    p.tilde <- rbind(rep(1,U), p)
    colnames(p.tilde) <- levels(as.factor(data$userId))
    q.tilde <- rbind(bi, q)
    
    for (i in 1:I) {
      # find all the users who rate movie i
      u.rated.i <- as.character(train[train$movieId==movie.id[i],]$userId)
      dev <- train[train$movieId==movie.id[i],]$dev
      q.tilde[,i] <- solve(p.tilde[,u.rated.i] %*% t(p.tilde[,u.rated.i]) + lambda* diag(f+1)) %*%
      p.tilde[,u.rated.i] %*% (train[train$movieId==movie.id[i],]$rating - mu - bu[,u.rated.i] - au[,u.rated.i]*dev)
    }
    
    # update bi and q
    bi[1,] <- q.tilde[1,]
    q <- q.tilde[-1,]
    
    # Rating Matrix
    mat <- t(p)%*%q
    
    bu_ui <- matrix(rep(NA, U*I), ncol = I)
    for (i in 1:I) {
      bu_ui[,i] <- t(bu)
    }
    
    bi_ui <- matrix(rep(NA, U*I), ncol = I)
    for (u in 1:U) {
      bi_ui[u, ] <- bi
    }
    
    au_dev_ui <- matrix(rep(0, U*I), ncol = I)
    au_dev_ui <- as.data.frame(au_dev_ui)
    colnames(au_dev_ui) <- levels(as.factor(data$movieId))
    for (i in 1:nrow(train)){
      user = train[i,"userId"] %>% as.numeric
      movie = train[i, "movieId"] %>% as.character
      au_dev_ui[user, movie] = au[user]*train[user,]$dev
    }
    colnames(au_dev_ui) = NULL
    au_dev_ui = as.matrix(au_dev_ui)
    
    mu_ui <- matrix(rep(mu, U*I), ncol = I)
    
    R <- mat + mu_ui + bu_ui + bi_ui + au_dev_ui
    
    # Summerize
    cat("iter:", l, "\t")
    est_rating <- as.matrix(R) 
    colnames(est_rating) <- levels(as.factor(data$movieId))
    rownames(est_rating) <- levels(as.factor(data$userId))
    
    train_RMSE_cur <- RMSE(train, est_rating)
    cat("training RMSE:", train_RMSE_cur, "\t")
    train_RMSE <- c(train_RMSE, train_RMSE_cur)
    
    test_RMSE_cur <- RMSE(test, est_rating)
    cat("test RMSE:",test_RMSE_cur, "\t")
    test_RMSE <- c(test_RMSE, test_RMSE_cur)
    
    E = Sys.time()
    
    cat("Time cost:", E-S, "min\n")
 }
  
return(list(p = p, q = q,
          train_RMSE = train_RMSE, test_RMSE = test_RMSE,
          est_rating = est_rating))
}
```

```{r}
result <- ALS.R1R3(f = 10, lambda = 5, beta = 0.4, max.iter = 10, train = data_train, test = data_test)
```

```{r}
save(result, file = '../output/resultR1R3.Rdata')
```

