library(dplyr)
library(tidyr)
library(ggplot2)
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(0)
test_idx <- sample(1:nrow(data), round(nrow(data)/5, 0))
train_idx <- setdiff(1:nrow(data), test_idx)
data_train <- data[train_idx,]
data_test <- data[test_idx,]
?gradesc
U <- length(unique(data$userId))
I <- length(unique(data$movieId))
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
f_list <- seq(10, 20, 10)
l_list <- seq(-2, -1, 1)
f_l <- expand.grid(f_list, l_list)
result_summary <- array(NA, dim = c(nrow(f_l), 10, 4))
run_time <- system.time(for(i in 1:nrow(f_l)){
par <- paste("f = ", f_l[i,1], ", lambda = ", 10^f_l[i,2])
cat(par, "\n")
current_result <- cv.function(data, K = 5, f = f_l[i,1], lambda = 10^f_l[i,2])
result_summary[,,i] <- matrix(unlist(current_result), ncol = 10, byrow = T)
print(result_summary)
})
nrow(f_l)
i=1
par <- paste("f = ", f_l[i,1], ", lambda = ", 10^f_l[i,2])
cat(par, "\n")
current_result <- cv.function(data, K = 5, f = f_l[i,1], lambda = 10^f_l[i,2])
K = 5
f = f_l[i,1]
lambda = 10^f_l[i,2]
dat_train=data
n <- dim(dat_train)[1]
n.fold <- round(n/K, 0)
set.seed(0)
s <- sample(rep(1:K, c(rep(n.fold, K-1), n-(K-1)*n.fold)))
train_rmse <- matrix(NA, ncol = 10,nrow = K)
test_rmse <- matrix(NA, ncol = 10, nrow = K)
i=1
train.data <- dat_train[s != i,]
test.data <- dat_train[s == i,]
result <- gradesc(f = f, lambda =lambda,
lrate = 0.01, max.iter = 100, stopping.deriv = 0.01,
data = dat_train, train = train.data, test = test.data)
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(cache = T)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
# options(mc.cores = parallel::detectCores())
library(dplyr)
library(tidyr)
library(ggplot2)
library(anytime)
data <- read.csv("../data/ml-latest-small/ratings.csv")
data <- read.csv("../data/ml-latest-small/ratings.csv")
data$timestamp <- anydate(data$timestamp)
data <- data %>%
group_by(userId) %>%
mutate(timediff = (timestamp - mean(timestamp)) %>% as.numeric) %>%
ungroup() %>%
arrange(timestamp)
data$timestamp <- anydate(data$timestamp)
data <- data %>%
group_by(userId) %>%
mutate(timediff = (timestamp - mean(timestamp)) %>% as.numeric) %>%
ungroup() %>%
arrange(timestamp)
set.seed(0)
## shuffle the row of the entire dataset
data <- data[sample(nrow(data)),]
## get a small dataset that contains all users and all movies
unique.user<-duplicated(data[,1])
unique.movie<-duplicated(data[,2])
index<-unique.user & unique.movie
all.user.movie <- data[!index,]
## split training and test on the rest
rest <- data[index,]
test_idx <- sample(rownames(rest), round(nrow(data)/5, 0))
train_idx <- setdiff(rownames(rest), test_idx)
## combine the training with the previous dataset, which has all users and all movies
data_train <- rbind(all.user.movie, data[train_idx,])
data_test <- data[test_idx,]
## sort the training and testing data by userId then by movieId,
## so when we update p and q, it is less likely to make mistakes
data_train <- arrange(data_train, userId, movieId)
data_test <- arrange(data_test, userId, movieId)
U <- length(unique(data$userId))
I <- length(unique(data$movieId))
RMSE <- function(rating, est_rating) {
error <- rep(NA, nrow(rating))
for (i in 1:nrow(rating)) {
a <- as.character(rating[i,1])
b <-as.character(rating[i,2])
error[i] <- (rating[i,3]-est_rating[a, b])^2
}
error = error %>% unlist()
return(sqrt(mean(error)))
}
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(cache = T)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
options(mc.cores = parallel::detectCores())
library(tidyverse)
library(ggplot2)
library(anytime)
library(caret)
library(parallel)
cl <- makeCluster(4) #***
data <- read.csv("../data/ml-latest-small/ratings.csv")
data$timestamp <- anydate(data$timestamp)
data <- data %>%
group_by(userId) %>%
mutate(timediff = (timestamp - mean(timestamp)) %>% as.numeric) %>%
ungroup() %>%
arrange(timestamp)
set.seed(1)
# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)
data_train <- data[train_ind, ]
data_test <- data[-train_ind, ]
RMSE <- function(rating, est_rating){
sqr_err <- function(id){
sqr_error <- (as.numeric(rating[id,3]) - est_rating[as.character(rating[id,1]), as.character(rating[id,2])])^2
return(sqr_error)
}
error = sapply(1:nrow(rating), sqr_err)
return(sqrt(mean(error)))
}
findSolve <- function(id, solveBy, train, lambda, user_mat, movie_mat, au, bu, bi, mu, f){
id <- as.integer(id)
# Fix Movies, solve User
if(solveBy == "Movies"){
# find all the users who rate movie i
U_set <- as.character(train[train$movieId == id,]$userId)
dev <- train[train$movieId == id,]$dev
user_mat_p = user_mat[,U_set]
Result = solve(user_mat_p %*% t(user_mat_p) + lambda* diag(f+1)) %*% user_mat_p %*% (train[train$movieId == id,]$rating - mu - bu[,U_set] - au[,U_set]*dev)
return(Result)
}
# Fix User, solve Movie
else if(solveBy == "Users"){
# find all the moives rated by user u
M_set <- as.character(train[train$userId == id,]$movieId)
x <- train[train$userId == id,]$rating
dev <- train[train$userId == id,]$dev
R <- matrix(x, ncol = length(x), nrow = 1)
cname <- colnames(movie_mat[,M_set])
movie_mat_p <- rbind(dev, movie_mat[,M_set])
colnames(movie_mat_p) <- cname
Result = solve(movie_mat_p %*% t(movie_mat_p) + lambda * diag(f+2)) %*% movie_mat_p %*% t(R - mu - bi[,M_set])
return(Result)
}
else return("Please let matSolv be in right way")
}
ALS.R1R3 <- function(f = 10, lambda = 5, beta = 0.4, maxIters = 5, data = data,
train = data_train, test = data_test){
train = train %>% mutate(dev = ifelse(timediff>0, 1, -1)*abs(timediff)^beta)
test = test %>% mutate(dev = ifelse(timediff>0, 1, -1)*abs(timediff)^beta)
all_data = rbind(train, test)
# Factorized the Movies and User matrices
UserId <- levels(as.factor(data$userId))
U <- length(UserId)
MovieId <- levels(as.factor(data$movieId))
M <- length(MovieId)
I<-M #***
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -10, 10)), nrow=f,byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -10, 10)), nrow=f,byrow = T)
colnames(Movies) <- MovieId
bu <- matrix(rep(0, U), ncol = U)
colnames(bu) <- UserId
bi <- matrix(rep(0, M), ncol = M)
colnames(bi) <- MovieId
R <- matrix(rep(0, U*M), ncol = M)
colnames(R) <- MovieId
au <- matrix(rep(0, U), ncol = U)
colnames(au) <- UserId
# mean of all the ratings in train data set.
Ave_rating <- mean(train$rating)
trainRMSE <- rep(NA, maxIters)
testRMSE <- rep(NA, maxIters)
clusterExport(cl, "findSolve", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
iter <- 1
while(iter <= maxIters){
S = Sys.time()
Movies_cal <- rbind(rep(1,M), Movies)
colnames(Movies_cal) <- MovieId
Users_cal <- rbind(au, bu, Users)
# Fix Movie, solve User
Users_cal <- parSapply(cl, as.character(UserId), findSolve, solveBy = "Users", train = train, lambda = lambda, user_mat = Users_cal, movie_mat = Movies_cal, au = au, bu = bu, bi = bi, mu = Ave_rating, f = f, USE.NAMES = T)
# Update au, bu and Users
au[1,] <- Users_cal[1, ]
bu[1,] <- Users_cal[2, ]
Users <- Users_cal[-c(1,2), ]
Users_cal <- rbind(rep(1,U), Users)
colnames(Users_cal) <- UserId
Movies_cal <- rbind(bi, Movies)
# Fix User, solve Movie
Movies_cal <- parSapply(cl, as.character(MovieId), findSolve, solveBy = "Movies", train = train, lambda = lambda, user_mat = Users_cal, movie_mat = Movies_cal, au = au, bu = bu, bi = bi, mu = Ave_rating, f = f, USE.NAMES = T)
# Update bi and Movies
bi[1,] <- Movies_cal[1,]
Movies <- Movies_cal[-1,]
# Rating Matrix
mat <- t(Users) %*% Movies
bu_ui <- matrix(rep(NA, U*M), ncol = M)
for (i in 1:M) {
bu_ui[,i] <- t(bu)
}
bi_ui <- matrix(rep(NA, U*M), ncol = M)
for (u in 1:U) {
bi_ui[u, ] <- bi
}
au_mat <- matrix(rep(au,I),nrow=U,byrow = F)
dev_mat <- all_data %>%
unique() %>%
select(userId, movieId, dev) %>%
arrange(userId, movieId) %>%
pivot_wider(userId, names_from = movieId, values_from = dev, values_fill = list(dev = 0)) %>%
select(-1)
colnames(dev_mat) <- colnames(dev_mat) %>% as.numeric()
dev_mat <- dev_mat %>% select(as.character(MovieId))
au_dev_ui <- au_mat*dev_mat
au_dev_ui <- as.matrix(au_dev_ui)
mu_ui <- matrix(rep(mu, U*I), ncol = I)
R <- mat + mu_ui + bu_ui + bi_ui + au_dev_ui
# RMSE
est_rating <- as.matrix(R)
trainRMSE[iter] <- RMSE(train, est_rating)
testRMSE[iter] <- RMSE(test, est_rating)
E = Sys.time()
cat("Iter", iter, "  RMSE for train set:", round(trainRMSE[iter], 4), "  RMSE for test set:", round(testRMSE[iter], 4), "  Time cost:", round(E-S, 2), "s\n")
iter <- iter + 1
}
# Result
ratings_est <- est_rating
return(list("User" = Users,
"Movie" = Movies,
"Rating" = ratings_est,
"Train RMSE" = trainRMSE,
"Test RMSE" = testRMSE)
)
}
result = ALS.R1R3(f = 10, lambda = 5, beta = 0.4, maxIters = 20 , data = data,
train = data_train, test = data_test)
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(cache = T)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
options(mc.cores = parallel::detectCores())
library(tidyverse)
library(ggplot2)
library(anytime)
library(caret)
library(parallel)
cl <- makeCluster(4) #***
data <- read.csv("../data/ml-latest-small/ratings.csv")
data$timestamp <- anydate(data$timestamp)
data <- data %>%
group_by(userId) %>%
mutate(timediff = (timestamp - mean(timestamp)) %>% as.numeric) %>%
ungroup() %>%
arrange(timestamp)
set.seed(1)
# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)
data_train <- data[train_ind, ]
data_test <- data[-train_ind, ]
RMSE <- function(rating, est_rating){
sqr_err <- function(id){
sqr_error <- (as.numeric(rating[id,3]) - est_rating[as.character(rating[id,1]), as.character(rating[id,2])])^2
return(sqr_error)
}
error = sapply(1:nrow(rating), sqr_err)
return(sqrt(mean(error)))
}
findSolve <- function(id, solveBy, train, lambda, user_mat, movie_mat, au, bu, bi, mu, f){
id <- as.integer(id)
# Fix Movies, solve User
if(solveBy == "Movies"){
# find all the users who rate movie i
U_set <- as.character(train[train$movieId == id,]$userId)
dev <- train[train$movieId == id,]$dev
user_mat_p = user_mat[,U_set]
Result = solve(user_mat_p %*% t(user_mat_p) + lambda* diag(f+1)) %*% user_mat_p %*% (train[train$movieId == id,]$rating - mu - bu[,U_set] - au[,U_set]*dev)
return(Result)
}
# Fix User, solve Movie
else if(solveBy == "Users"){
# find all the moives rated by user u
M_set <- as.character(train[train$userId == id,]$movieId)
x <- train[train$userId == id,]$rating
dev <- train[train$userId == id,]$dev
R <- matrix(x, ncol = length(x), nrow = 1)
cname <- colnames(movie_mat[,M_set])
movie_mat_p <- rbind(dev, movie_mat[,M_set])
colnames(movie_mat_p) <- cname
Result = solve(movie_mat_p %*% t(movie_mat_p) + lambda * diag(f+2)) %*% movie_mat_p %*% t(R - mu - bi[,M_set])
return(Result)
}
else return("Please let matSolv be in right way")
}
ALS.R1R3 <- function(f = 10, lambda = 5, beta = 0.4, maxIters = 5, data = data,
train = data_train, test = data_test){
train = train %>% mutate(dev = ifelse(timediff>0, 1, -1)*abs(timediff)^beta)
test = test %>% mutate(dev = ifelse(timediff>0, 1, -1)*abs(timediff)^beta)
all_data = rbind(train, test)
# Factorized the Movies and User matrices
UserId <- levels(as.factor(data$userId))
U <- length(UserId)
MovieId <- levels(as.factor(data$movieId))
M <- length(MovieId)
I<-M #***
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -10, 10)), nrow=f,byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -10, 10)), nrow=f,byrow = T)
colnames(Movies) <- MovieId
bu <- matrix(rep(0, U), ncol = U)
colnames(bu) <- UserId
bi <- matrix(rep(0, M), ncol = M)
colnames(bi) <- MovieId
R <- matrix(rep(0, U*M), ncol = M)
colnames(R) <- MovieId
au <- matrix(rep(0, U), ncol = U)
colnames(au) <- UserId
# mean of all the ratings in train data set.
Ave_rating <- mean(train$rating)
mu<-Ave_rating #***
trainRMSE <- rep(NA, maxIters)
testRMSE <- rep(NA, maxIters)
clusterExport(cl, "findSolve", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
iter <- 1
while(iter <= maxIters){
S = Sys.time()
Movies_cal <- rbind(rep(1,M), Movies)
colnames(Movies_cal) <- MovieId
Users_cal <- rbind(au, bu, Users)
# Fix Movie, solve User
Users_cal <- parSapply(cl, as.character(UserId), findSolve, solveBy = "Users", train = train, lambda = lambda, user_mat = Users_cal, movie_mat = Movies_cal, au = au, bu = bu, bi = bi, mu = Ave_rating, f = f, USE.NAMES = T)
# Update au, bu and Users
au[1,] <- Users_cal[1, ]
bu[1,] <- Users_cal[2, ]
Users <- Users_cal[-c(1,2), ]
Users_cal <- rbind(rep(1,U), Users)
colnames(Users_cal) <- UserId
Movies_cal <- rbind(bi, Movies)
# Fix User, solve Movie
Movies_cal <- parSapply(cl, as.character(MovieId), findSolve, solveBy = "Movies", train = train, lambda = lambda, user_mat = Users_cal, movie_mat = Movies_cal, au = au, bu = bu, bi = bi, mu = Ave_rating, f = f, USE.NAMES = T)
# Update bi and Movies
bi[1,] <- Movies_cal[1,]
Movies <- Movies_cal[-1,]
# Rating Matrix
mat <- t(Users) %*% Movies
bu_ui <- matrix(rep(NA, U*M), ncol = M)
for (i in 1:M) {
bu_ui[,i] <- t(bu)
}
bi_ui <- matrix(rep(NA, U*M), ncol = M)
for (u in 1:U) {
bi_ui[u, ] <- bi
}
au_mat <- matrix(rep(au,I),nrow=U,byrow = F)
dev_mat <- all_data %>%
unique() %>%
select(userId, movieId, dev) %>%
arrange(userId, movieId) %>%
pivot_wider(userId, names_from = movieId, values_from = dev, values_fill = list(dev = 0)) %>%
select(-1)
colnames(dev_mat) <- colnames(dev_mat) %>% as.numeric()
dev_mat <- dev_mat %>% select(as.character(MovieId))
au_dev_ui <- au_mat*dev_mat
au_dev_ui <- as.matrix(au_dev_ui)
mu_ui <- matrix(rep(mu, U*I), ncol = I)
R <- mat + mu_ui + bu_ui + bi_ui + au_dev_ui
# RMSE
est_rating <- as.matrix(R)
trainRMSE[iter] <- RMSE(train, est_rating)
testRMSE[iter] <- RMSE(test, est_rating)
E = Sys.time()
cat("Iter", iter, "  RMSE for train set:", round(trainRMSE[iter], 4), "  RMSE for test set:", round(testRMSE[iter], 4), "  Time cost:", round(E-S, 2), "s\n")
iter <- iter + 1
}
# Result
ratings_est <- est_rating
return(list("User" = Users,
"Movie" = Movies,
"Rating" = ratings_est,
"Train RMSE" = trainRMSE,
"Test RMSE" = testRMSE)
)
}
result = ALS.R1R3(f = 10, lambda = 5, beta = 0.4, maxIters = 20 , data = data,
train = data_train, test = data_test)
save(result, file = '../output/resultR1R3.Rdata')
