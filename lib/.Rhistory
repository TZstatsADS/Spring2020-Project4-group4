clusterExport(cl, "Users", envir = environment())
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
# data=dat_train
# train=train.data
# test=test.data
# f=f
# maxIters=maxIter
lambda=lambdas_als
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
train%>%dim
as.character(UserId)
as.character(UserId)[1]
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
ALS <- function(data, train, test, f, maxIters, lambda=5){
# Factorized the Movies and User matrices
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
iter <- 1
while(iter <= maxIters){
st <- Sys.time()
# Fix Movie, solve User
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
# Fix User, solve Movie
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
# cat("Iter:", iter,  "\t Time spent:", round(Sys.time()-st, 3), "s\n")
# if(iter%%3==1){
#   est_rating <- t(Users) %*% Movies
#
#   trainRMSE[iter%/%3+1] <- RMSE(train, est_rating)
#   testRMSE[iter%/%3+1] <- RMSE(test, est_rating)
# }
cat(".")
if(iter==maxIters) cat("\n")
iter <- iter + 1
}
# RMSE
est_rating <- t(Users) %*% Movies
trainRMSE <- RMSE(train, est_rating)
testRMSE <- RMSE(test, est_rating)
return(list("User" = Users,
"Movie" = Movies,
"Rating" = est_rating,
"TrainRMSE" = trainRMSE,
"TestRMSE" = testRMSE))
}
data=dat_train
train=train.data
test=test.data
f=f
maxIters=maxIter
lambda=lambdas_als
lambda_p=lambdas_p
sigma=sigmas
result_ALS <- ALS(data, train, test, f, maxIters, lambda_als)
lambda=lambdas_als
lambdas_als
lambda
result_ALS <- ALS(data, train, test, f, maxIters, lambda_als)
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
iter <- 1
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users
Users%>%dim
# Fix User, solve Movie
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
Users%>%dim
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
iter <- 1
st <- Sys.time()
# Fix Movie, solve User
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
Users
Users%>%dim
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
cl
# Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
x <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
# Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
x <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
train
train%>%dim
lambda%>%dim
lambda
library(tidyverse)
library(caret)
library(parallel)
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(1)
# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)
train <- data[train_ind, ]
test <- data[-train_ind, ]
RMSE <- function(rating, est_rating){
sqr_err <- function(obs){
sqr_error <- (obs[3] - est_rating[as.character(obs[1]), as.character(obs[2])])^2
return(sqr_error)
}
return(sqrt(mean(apply(rating, 1, sqr_err))))
}
minFunc <- function(rating, matSolv, lambda){
solve(matSolv %*% t(matSolv) + lambda * diag(f)) %*% matSolv %*% rating
}
# The Function used to Find the
findSolve <- function(id, solveBy, train, lambda){
id <- as.integer(id)
# Fix Movies, solve User
if(solveBy=="Movies"){
movId <- train[train$userId==id, ]$movieId
movSolv <- Movies[, as.character(movId)]
rating <- train[train$userId==id, ]$rating
minFunc(rating = rating, matSolv = movSolv, lambda = lambda)
}
# Fix User, solve Movie
else if(solveBy=="Users"){
userId <- train[train$movieId==id, ]$userId
userSolv <- Users[, as.character(userId)]
rating <- train[train$movieId==id, ]$rating
minFunc(rating = rating, matSolv = userSolv, lambda = lambda)
}
else return("Please let matSolv be in right way")
}
# Factorized the Movies and User matrices
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
iter <- 1
# Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
x <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
# Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
x <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
# Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
x <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
clusterExport(cl, "Users", envir = environment())
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
library(tidyverse)
library(caret)
library(parallel)
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(1)
# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)
train <- data[train_ind, ]
test <- data[-train_ind, ]
RMSE <- function(rating, est_rating){
sqr_err <- function(obs){
sqr_error <- (obs[3] - est_rating[as.character(obs[1]), as.character(obs[2])])^2
return(sqr_error)
}
return(sqrt(mean(apply(rating, 1, sqr_err))))
}
minFunc <- function(rating, matSolv, lambda){
solve(matSolv %*% t(matSolv) + lambda * diag(f)) %*% matSolv %*% rating
}
# The Function used to Find the
findSolve <- function(id, solveBy, train, lambda){
id <- as.integer(id)
# Fix Movies, solve User
if(solveBy=="Movies"){
movId <- train[train$userId==id, ]$movieId
movSolv <- Movies[, as.character(movId)]
rating <- train[train$userId==id, ]$rating
minFunc(rating = rating, matSolv = movSolv, lambda = lambda)
}
# Fix User, solve Movie
else if(solveBy=="Users"){
userId <- train[train$movieId==id, ]$userId
userSolv <- Users[, as.character(userId)]
rating <- train[train$movieId==id, ]$rating
minFunc(rating = rating, matSolv = userSolv, lambda = lambda)
}
else return("Please let matSolv be in right way")
}
ALS <- function(data, train, test, f, maxIters, lambda=5){
# Factorized the Movies and User matrices
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
iter <- 1
while(iter <= maxIters){
st <- Sys.time()
# Fix Movie, solve User
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
# Fix User, solve Movie
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
# cat("Iter:", iter,  "\t Time spent:", round(Sys.time()-st, 3), "s\n")
# if(iter%%3==1){
#   est_rating <- t(Users) %*% Movies
#
#   trainRMSE[iter%/%3+1] <- RMSE(train, est_rating)
#   testRMSE[iter%/%3+1] <- RMSE(test, est_rating)
# }
cat(".")
if(iter==maxIters) cat("\n")
iter <- iter + 1
}
# RMSE
est_rating <- t(Users) %*% Movies
trainRMSE <- RMSE(train, est_rating)
testRMSE <- RMSE(test, est_rating)
return(list("User" = Users,
"Movie" = Movies,
"Rating" = est_rating,
"TrainRMSE" = trainRMSE,
"TestRMSE" = testRMSE))
}
# # set the number of cores to use
# cl <- makeCluster(8)
# result <- ALS(data, train, test, f = 10, maxIters = 15, lambda = 1)
# stopCluster(cl)
source("../lib/cross_validation.R")
source("../lib/P3.R")
fs <- c(5, 10, 15, 20)
lambdas_als <- c(1, 5, 8, 10)
lambdas_P <- c(1, 5, 10, 15, 20)
sigmas <- c(1,2,3,4,5)
cv.df <- expand.grid("fs"=fs,
"lambdas_als"=lambdas_als,
"lambdas_p"=lambdas_P,
"sigmas" =sigmas)
ALS_KRR <- function(data, train, test, f, maxIters, lambda_als, lambda_p, sigma){
# data=dat_train
# train=train.data
# test=test.data
# f=f
# maxIters=maxIter
# lambda=lambdas_als
# lambda_p=lambdas_p
# sigma=sigmas
result_ALS <- ALS(data, train, test, f, maxIters, lambda_als)
KRR.Post(result_ALS=result_ALS,lambda=lambda_p, sigma=sigma, data, train, test)
}
x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA,train_sd=NA,test_sd=NA)%>%head(1)
x
i
tmp=cv.functionYQ(dat_train = data,K=2,f=x[i,]$fs,maxIter =2,lambdas_als = x[i,]$lambdas_als,lambdas_p = x[i,]$lambdas_p,sigmas =  x[i,]$sigmas)
ALS_KRR(dat_train,train.data,test.data,f=f,maxIters =maxIter,lambdas_als,lambdas_p, sigmas)
ALS_KRR(dat_train,train.data,test.data,f=f,maxIters =maxIter,lambdas_als,lambdas_p, sigmas)
result <- ALS_KRR(data,train,test,f=f,maxIters =maxIter,lambdas_als,lambdas_p, sigmas)
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(1)
# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)
train <- data[train_ind, ]
test <- data[-train_ind, ]
result <- ALS_KRR(data,train,test,f=f,maxIters =maxIter,lambdas_als,lambdas_p, sigmas)
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(1)
# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)
train <- data[train_ind, ]
test <- data[-train_ind, ]
RMSE <- function(rating, est_rating){
sqr_err <- function(obs){
sqr_error <- (obs[3] - est_rating[as.character(obs[1]), as.character(obs[2])])^2
return(sqr_error)
}
return(sqrt(mean(apply(rating, 1, sqr_err))))
}
minFunc <- function(rating, matSolv, lambda){
solve(matSolv %*% t(matSolv) + lambda * diag(f)) %*% matSolv %*% rating
}
# The Function used to Find the
findSolve <- function(id, solveBy, train, lambda){
id <- as.integer(id)
# Fix Movies, solve User
if(solveBy=="Movies"){
movId <- train[train$userId==id, ]$movieId
movSolv <- Movies[, as.character(movId)]
rating <- train[train$userId==id, ]$rating
minFunc(rating = rating, matSolv = movSolv, lambda = lambda)
}
# Fix User, solve Movie
else if(solveBy=="Users"){
userId <- train[train$movieId==id, ]$userId
userSolv <- Users[, as.character(userId)]
rating <- train[train$movieId==id, ]$rating
minFunc(rating = rating, matSolv = userSolv, lambda = lambda)
}
else return("Please let matSolv be in right way")
}
ALS <- function(data, train, test, f, maxIters, lambda=5){
# Factorized the Movies and User matrices
UserId <- unique(data$userId)
U <- length(UserId)
MovieId <- unique(data$movieId)
M <- length(MovieId)
avgRatingByUser <- data %>%
group_by(userId) %>%
summarise(avgRating = mean(rating))
avgRatingByMovie <- data %>%
group_by(movieId) %>%
summarise(avgRating = mean(rating))
Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
colnames(Users) <- UserId
Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
colnames(Movies) <- MovieId
clusterExport(cl, "minFunc", envir = environment())
clusterExport(cl, "f", envir = environment())
clusterExport(cl, "UserId", envir = environment())
clusterExport(cl, "MovieId", envir = environment())
trainRMSE <- rep(NA, maxIters%/%3)
testRMSE <- rep(NA, maxIters%/%3)
iter <- 1
while(iter <= maxIters){
st <- Sys.time()
# Fix Movie, solve User
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
# Fix User, solve Movie
clusterExport(cl, "Movies", envir = environment())
clusterExport(cl, "Users", envir = environment())
Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
# cat("Iter:", iter,  "\t Time spent:", round(Sys.time()-st, 3), "s\n")
# if(iter%%3==1){
#   est_rating <- t(Users) %*% Movies
#
#   trainRMSE[iter%/%3+1] <- RMSE(train, est_rating)
#   testRMSE[iter%/%3+1] <- RMSE(test, est_rating)
# }
cat(".")
if(iter==maxIters) cat("\n")
iter <- iter + 1
}
# RMSE
est_rating <- t(Users) %*% Movies
trainRMSE <- RMSE(train, est_rating)
testRMSE <- RMSE(test, est_rating)
return(list("User" = Users,
"Movie" = Movies,
"Rating" = est_rating,
"TrainRMSE" = trainRMSE,
"TestRMSE" = testRMSE))
}
# # set the number of cores to use
cl <- makeCluster(8)
result <- ALS(data, train, test, f = 10, maxIters = 15, lambda = 1)
cl <- makeCluster(8)
x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA,train_sd=NA,test_sd=NA)%>%head(1)
for (i in 1:dim(x)[1]){
tmp=cv.functionYQ(dat_train = data,K=2,f=x[i,]$fs,maxIter =2,lambdas_als = x[i,]$lambdas_als,lambdas_p = x[i,]$lambdas_p,sigmas =  x[i,]$sigmas)
x[i,"train_mean"]=tmp$mean_train_rmse
x[i,"test_mean"]=tmp$mean_test_rmse
x[i,"train_sd"]=tmp$sd_train_rmse
x[i,"test_sd"]=tmp$sd_test_rmse
}
x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA,train_sd=NA,test_sd=NA)#%>%head(2)
x
cl <- makeCluster(8)
x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA,train_sd=NA,test_sd=NA)#%>%head(2)
for (i in 1:100){
tmp=cv.functionYQ(dat_train = data,K=2,f=x[i,]$fs,maxIter =2,lambdas_als = x[i,]$lambdas_als,lambdas_p = x[i,]$lambdas_p,sigmas =  x[i,]$sigmas)
x[i,"train_mean"]=tmp$mean_train_rmse
x[i,"test_mean"]=tmp$mean_test_rmse
x[i,"train_sd"]=tmp$sd_train_rmse
x[i,"test_sd"]=tmp$sd_test_rmse
}
cl <- makeCluster(8)
x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA,train_sd=NA,test_sd=NA)#%>%head(2)
for (i in 1:100){
tmp=cv.functionYQ(dat_train = data,K=5,f=x[i,]$fs,maxIter =15,lambdas_als = x[i,]$lambdas_als,lambdas_p = x[i,]$lambdas_p,sigmas =  x[i,]$sigmas)
x[i,"train_mean"]=tmp$mean_train_rmse
x[i,"test_mean"]=tmp$mean_test_rmse
x[i,"train_sd"]=tmp$sd_train_rmse
x[i,"test_sd"]=tmp$sd_test_rmse
}
x
xi
i
save(x, file="../output/cvtmp.RData")
