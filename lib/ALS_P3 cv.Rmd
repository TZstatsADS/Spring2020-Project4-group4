---
title: "ALS Model"
author: "Yuqiao Liu & Guoying Li"
output: html_notebook
---

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(caret)
library(parallel)
```

# Load the data (in main.rmd)
```{r}
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(1)

# train-test split (.8/.2)
train_ind <- createDataPartition(data$userId, p=.8, list=F)


train <- data[train_ind, ]
test <- data[-train_ind, ]
train_path = '../data/train_set.csv'
test_path = '../data/test_set.csv'
#write.csv(train, train_path)
#write.csv(test, test_path)

```

# RMSE & Used Funcs
```{r}
RMSE <- function(rating, est_rating){
  sqr_err <- function(obs){
    sqr_error <- (obs[3] - est_rating[as.character(obs[1]), as.character(obs[2])])^2
    return(sqr_error)
  }
  return(sqrt(mean(apply(rating, 1, sqr_err))))  
}

minFunc <- function(rating, matSolv, lambda){
    solve(matSolv %*% t(matSolv) + lambda * diag(f)) %*% matSolv %*% rating
  }

# The Function used to Find the 
findSolve <- function(id, solveBy, train, lambda){
  id <- as.integer(id)
  # Fix Movies, solve User
  if(solveBy=="Movies"){
    movId <- train[train$userId==id, ]$movieId
    movSolv <- Movies[, as.character(movId)]
    rating <- train[train$userId==id, ]$rating
    
    minFunc(rating = rating, matSolv = movSolv, lambda = lambda)
    
  }
  # Fix User, solve Movie
  else if(solveBy=="Users"){
    userId <- train[train$movieId==id, ]$userId
    userSolv <- Users[, as.character(userId)]
    rating <- train[train$movieId==id, ]$rating

    minFunc(rating = rating, matSolv = userSolv, lambda = lambda)
  }
  else return("Please let matSolv be in right way")
}
```

# ALS
```{r}
ALS <- function(data, train, test, f, maxIters, lambda=5){
  # Factorized the Movies and User matrices
  UserId <- unique(data$userId)
  U <- length(UserId)
  
  MovieId <- unique(data$movieId)
  M <- length(MovieId)
  
  avgRatingByUser <- data %>% 
    group_by(userId) %>% 
    summarise(avgRating = mean(rating))
  
  avgRatingByMovie <- data %>% 
    group_by(movieId) %>% 
    summarise(avgRating = mean(rating))
  
  Users <- matrix(c(avgRatingByUser$avgRating, runif((f-1)*U, -1, 1)), nrow=f, byrow = T)
  colnames(Users) <- UserId
  
  Movies <- matrix(c(avgRatingByMovie$avgRating, rnorm((f-1)*M, -1, 1)), nrow=f, byrow = T)
  colnames(Movies) <- MovieId
  
  clusterExport(cl, "minFunc", envir = environment())
  clusterExport(cl, "f", envir = environment())
  clusterExport(cl, "UserId", envir = environment())
  clusterExport(cl, "MovieId", envir = environment())
  
  trainRMSE <- rep(NA, maxIters%/%3)
  testRMSE <- rep(NA, maxIters%/%3)
  
  iter <- 1
  while(iter <= maxIters){
    st <- Sys.time()
    # Fix Movie, solve User
    clusterExport(cl, "Movies", envir = environment())
    clusterExport(cl, "Users", envir = environment())
    Users <- parSapply(cl, as.character(UserId), findSolve, solveBy="Movies", train = train, lambda = lambda, USE.NAMES = T)
    # Fix User, solve Movie
    
    clusterExport(cl, "Movies", envir = environment())
    clusterExport(cl, "Users", envir = environment())
    Movies <- parSapply(cl, as.character(MovieId), findSolve, solveBy="Users", train = train, lambda = lambda, USE.NAMES = T)
    # cat("Iter:", iter,  "\t Time spent:", round(Sys.time()-st, 3), "s\n")
    
    # if(iter%%3==1){
    #   est_rating <- t(Users) %*% Movies
    #   
    #   trainRMSE[iter%/%3+1] <- RMSE(train, est_rating)
    #   testRMSE[iter%/%3+1] <- RMSE(test, est_rating)
    # }
    
    cat(".")
    if(iter==maxIters) cat("\n")
    iter <- iter + 1
  }
  # RMSE
  est_rating <- t(Users) %*% Movies
  trainRMSE <- RMSE(train, est_rating)
  testRMSE <- RMSE(test, est_rating)
  
  
  
  return(list("User" = Users, 
              "Movie" = Movies, 
              "Rating" = est_rating, 
              "TrainRMSE" = trainRMSE, 
              "TestRMSE" = testRMSE))
}

```

# Test
```{r, warning=FALSE, message=FALSE}
# # set the number of cores to use
# cl <- makeCluster(8)
# result <- ALS(data, train, test, f = 10, maxIters = 15, lambda = 1)
# stopCluster(cl)

```

# CV
```{r}
source("../lib/cross_validation.R")
source("../lib/P3.R")

fs <- c(5, 10, 15)
lambdas_als <- c(1, 5,10)
lambdas_P <- c(1, 5, 10)
sigmas <- c(1,2,3)

cv.df <- expand.grid("f"=fs, 
                     "lambda_als"=lambdas_als, 
                     "lambda_p"=lambdas_P, 
                     "sigma" =sigmas)

```

```{r}
ALS_KRR <- function(data, train, test, f, maxIters, lambda_als, lambda_p, sigma){
  # data=dat_train
  # train=train.data
  # test=test.data
  # f=f
  # maxIters=maxIter
  # lambda=lambdas_als
  # lambda_p=lambdas_p
  # sigma=sigmas
  result_ALS <- ALS(data, train, test, f, maxIters, lambda_als)
  KRR.Post(result_ALS=result_ALS,lambda=lambda_p, sigma=sigma, data, train, test)
}

```

```{r}
cl <- makeCluster(8)
load( file="../output/cvtmp.RData")

# x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA,train_sd=NA,test_sd=NA)#%>%head(2)
# x=cv.df%>%as_tibble()%>%mutate(train_mean=NA,test_mean=NA)
for (i in 47:dim(x)[1]){
  tmp=cv.functionYQ(dat_train = data,K=5,f=x[i,]$fs,maxIter =15,lambdas_als = x[i,]$lambdas_als,lambdas_p = x[i,]$lambdas_p,sigmas =  x[i,]$sigmas)
  x[i,"train_mean"]=tmp$mean_train_rmse
  x[i,"test_mean"]=tmp$mean_test_rmse
  # x[i,"train_sd"]=tmp$sd_train_rmse
  # x[i,"test_sd"]=tmp$sd_test_rmse
  rm(tmp)
}
save(x, file="../output/cvtmp.RData")
# load(x, file="../output/cvtmp.RData")
stopCluster(cl)
```





```{r, warning=FALSE, message=FALSE}
# cl <- makeCluster(8)
# 
# maxIter <- 15
# colNM <- c(1:maxIter)[c(1:maxIter)%%3 ==1]
# 
# # maxIter vs. f
# trainRMSE_f <- matrix(NA, nrow=length(fs), ncol=(maxIter%/%3))
# testRMSE_f <- matrix(NA, nrow=length(fs), ncol=(maxIter%/%3))
# 
# colnames(trainRMSE_f) <- colNM
# colnames(testRMSE_f) <-  colNM
# 
# row.names(trainRMSE_f) <- fs
# row.names(testRMSE_f) <- fs
# 
# 
# 
# # maxIter vs. lambda
# trainRMSE_lamd <- matrix(NA, nrow=length(lambdas), ncol=(maxIter%/%3))
# testRMSE_lamd <- matrix(NA, nrow=length(lambdas), ncol=(maxIter%/%3))
# 
# colnames(trainRMSE_lamd) <- colNM
# colnames(testRMSE_lamd) <-  colNM
# 
# row.names(trainRMSE_lamd) <- lambdas
# row.names(testRMSE_lamd) <- lambdas
# 
# # maxIter vs. f
# for(f in 1:length(fs)){
#   t = Sys.time()
#     
#   result <- cv.functionYQ(train, K=5, f = fs[f], lambda = 1, maxIter=maxIter)
#     
#     
#   print(paste0("", "f: ", fs[f], "    lambda: ", 1, "    Time: ", Sys.time()-t))
#     
#   trainRMSE_f[f, ] <- (result$mean_train_rmse)
#   testRMSE_f[f, ] <- (result$mean_test_rmse)
# }
# 
# # maxIter vs. lambda
# for(l in 1:length(lambdas)){
#   t = Sys.time()
#     
#   result <- cv.functionYQ(train, K=5, f = 10, lambda = lambdas[l], maxIter=maxIter)
#     
#     
#   print(paste0("", "f: ", 10, "    lambda: ", lambdas[l], "    Time: ", Sys.time()-t))
#     
#   trainRMSE_lamd[l, ] <- (result$mean_train_rmse)
#   testRMSE_lamd[l, ] <- (result$mean_test_rmse)
# }
# 
# stopCluster(cl)
# 
# save(trainRMSE_f, testRMSE_f, trainRMSE_lamd, testRMSE_lamd, file="../output/baseAlsCV.RData")
```

```{r}
load(file="../output/baseAlsCV.RData")
```

```{r}
plot_cv <- function(df){
  parameter=df %>% 
    rownames()
  iter <- df %>% 
    colnames()
  tmp <- df %>%
    as_tibble() %>%
    mutate(parameter=parameter) %>%
    pivot_longer(-parameter,
                 names_to = "iter",
                 values_to = "RMSE") %>%
    mutate(iter=as.numeric(iter))
  plot <- ggplot() +
    geom_line(data=tmp,
              mapping=aes(x=iter,
                          y=RMSE,
                          color=parameter)) + 
    theme_light()
  
  return(plot)
}
```




```{r}
trainf <- plot_cv(trainRMSE_f)
trainf +
  labs(title="CV train_RMSE for f")
```

```{r}
testf=plot_cv(testRMSE_f)
testf +
  labs(title="CV test_RMSE for f")
```

```{r}
trainlamd <- plot_cv(trainRMSE_lamd)
trainlamd + 
  labs(title="CV train_RMSE for lambda")
```


```{r}
testlamd <- plot_cv(testRMSE_lamd)
testlamd +
  labs(title="CV test_RMSE for lambda")
```

```{r}
library(tidyverse)
resultALS <- ALS(data, train, test, f = 5, maxIters =10 , lambda =5)
save(resultALS, file = "../output/resultALS.RData")


```




# P3

```{r}

```

```{r}

# krr.cv.rmse <- matrix(0, nrow = length(lambda), ncol = 4)
#   for(i in 1:length(lambda)){
#     for (j in 1:length(sigma)){
#     cat("lambda=", lambda[i],"sigma=", sigma[j], "\n")
#     krr.cv.rmse[i,] <- krr.cv (dat_train=data, K.fold=3, lambda=lambda[i],sigma=sigma[j])
#     }
#   }
krr.cv.rmse <- matrix(0, nrow = length(lambda), ncol = 4)
  for(i in 1:length(lambda)){

    cat("lambda=", lambda[i], "\n")
    krr.cv.rmse[i,] <- krr.cv (dat_train=data, K.fold=3, lambda=lambda[i],sigma=1)

  }
save(krr.cv.rmse, file="../output/krr.cv.rmse.RData")
```

```{r}
test=KRR.Post(lambda = 1, data = data, train = train, test = test)
```

```{r}
test=krr.cv (dat_train=data, K.fold=2, lambda=1,sigma=1.5)
```

## continue..
```{r}
#the r matrix and q matrix for factor of 10, lambda of 5 and RMSE
als1 <- ALS(data, train, test, f = 10, maxIters = 15, lambda = 1)
mat1= als1$Movies
mat2=t(as.matrix(als$Users))%*%as.matrix(als$Movie)
write.csv(mat1, file = "../output/A3_q_dim10.csv")
write.csv(mat2, file = "../output/A3_r_dim10.csv")
```


